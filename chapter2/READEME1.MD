#第二章 函数（Function）

#第十四条：尽量用异常来表示特殊情况，而不是返回None
1、编写工具函数(utility function)时，应给None返回值赋予特殊的意义。
2、用None返回值时，易产生调用者犯错，因为None和0以及空字符之类的值，在表达式上评估为Flase。
3、函数在遇到特殊情况时，应抛出异常，而不是只返回None。


#第十五条：了解在闭包里使用外围作用域中的变量。
1、python 支持闭包（closure）：闭包是一种定义在某个作用域中的函数，这种函数
   引用了那个作用域里面的变量。
2、Python的函数是一级对象（first-class object），即可直接引用函数、把函数赋给变量
   把函数当成参数传给其他函数，并通过表达式以及if语句对其进行比较判断。
3、表达式引用变量是，Python解释器将按当前函数作用域、任何外围作用域、包含当前代码的
   那个模块的作用域（全局作用域，global scope）以及内置作用域（包含len以及
   str等函数的作用域）等四个作用域来遍历。如没有定义过名称的变量，则抛出异常。
4、给变量赋值时，如当前作用域已经定义了这个变量，则该变量会被赋给新值。如没有 
   则会把这次赋值视为改变该变量的定义，而新定义的变量，其作用域就是包含赋值操作的
   这个函数。
5、作用域bug（scoping bug）：为了防止函数中局部变量污染函数外的那个模块。即每次赋值
   操作，都会影响外围模块的全景作用域。
6、python3特殊写法：用nonlocal语句获取包内数据。在闭包内用之赋值，修改的是闭包外的作用域变量。
7、建议不要用nonlocal语句，用辅助类（helper class）比较好，能达到一样的效果。


#第十六条：考虑用生成器来改写直接返回列表的函数
1、生成器是使用yield表达式的函数。
2、调用生成器时，其并不真的运行，而是会返回迭代器，其可以传给内置的list函数，将其转换为列表。
3、生成器可以应对任意长度的输入数据。
4、使用生成器比收集到的结果放到列表里返回给调用者更加清晰。
5、由生成器函数所返回的那个迭代器，可以把生成器函数整体中，传给yield表达式
   的那些值，逐次产生出来。
6、无论输入量多大，生成器都能产生一系列输出，因为这些输入量和输出量，都不会影响它执行时所消耗的内存。


#第十七条：在参数上面迭代时，要多加小心
1、标准化函数（normalization function）也称正规化函数或归一化函数。
2、函数在输入的参数上面多次迭代要当心，如果参数是迭代器，可能会导致
   奇怪的行为并错失某些值。
3、Python的迭代器

#第十八条：用数量可变的位置参数减少视觉杂讯
1、令函数接受可选的位置参数（习惯写成*args，又称star args，星号参数），使代码清晰，减少视觉杂讯。
2、变长参数传递给函数时，总先转化为元组（tuple），易造成程序崩溃。
3、变长参数使用后如增加新的位置参数，必须修改原调用该函数旧的代码，否则易出难以调试的错误。

#第十九条：用关键字参数来表达可选的行为
1、位置参数必须出现在关键字参数之前。
2、使用关键字参数有三个优点：首先易理解；其次函数定义中提供默认值；最后可以扩充函数参数。

#第二十条：用None和文档字符串来描述具有动态默认值的参数
1、参数的默认值，只会在程序加载模块并读到本函数的定义时评估一次。对于{}或[]等动态值会导致奇怪的行为。
2、对于以动态值作为实际默认参数的关键字参数，应把形式上的默认值写成None，并在函数的文档字符串黎明描述该默认值对应的实际行为。
